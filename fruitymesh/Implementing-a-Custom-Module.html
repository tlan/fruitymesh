<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Untitled :: Fruitymesh</title>
  <link rel="canonical" href="http://mwaylabs.github.io/fruitymesh/fruitymesh/Implementing-a-Custom-Module.html">
  <meta name="generator" content="Antora 2.1.1">
  <link rel="stylesheet" href="../_/css/site.css">
  <link rel="stylesheet" href="../_/css/footer.css">
</head>

<body class="article">
  <header class="header" role="banner">
<header class="header" role="banner">
  <div class="navbar-top">
    <a class="navbar-logo" id="fruitymesh-logo-padding" href="https://mwaylabs.github.io/fruitymesh/fruitymesh/index.html">
      <div class="navbar-item">
        <img src="../_/img/fruitymesh_logo.png" alt="Fruitymesh">
      </div>
    </a>
    <div class="navbar-item">
      <div id="search-wrapper" class="border-color-fruitymesh>
        <input id="search-input" type="text" placeholder="Search...">
      </div>
    </div>
  </div>
  <nav class="navbar-bottom fruitymesh-header-color">
    <a href="https://github.com/mwaylabs/fruitymesh">
      <div class="navbar-item">Fruitymesh on Github</div>
    </a>
  </nav>
</header>

</header>
  <div class="main-wrapper">
<div class="navigation-container" data-component="" data-version="master">
  <aside class="navigation" role="navigation">
    <div class="panels">
<div class="navigation-menu is-active" data-panel="menu">
  <button class="navigation-toggle"></button>
  <nav class="nav-menu">
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
    <ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="Quick-Start.html">Quick Start</a>
      </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="BasicUsage.html">Basic Usage</a>
      </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="Concepts.html">Concepts</a>
      </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="Features.html">Features</a>
      </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="Specification.html">Specification</a>
      </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-toggle"></button>
    <span class="nav-text">Developers</span>
    <ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Developers.html">Developer Overview</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Class-Structure.html">Class Structure</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Debugging.html">Debugging</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="ModuleDocumentationTemplate.html">Module Documentation Template</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="BuildingWithCMake.html">Building with CMake</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VsCodeSetup.html">VsCode Setup</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="CppCheck.html">CppCheck Setup</a>
      </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-toggle"></button>
    <span class="nav-text">Mesh</span>
    <ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Node.html">Node</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Connections.html">Connections</a>
      </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-toggle"></button>
    <span class="nav-text">Core Functionality</span>
    <ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="AdvertisingController.html">AdvertisingController</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="BoardConfig.html">Board Configuration</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="FruityHal.html">FruityHal</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Logger.html">Logger</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="RawData.html">RawData Protocol</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="RecordStorage.html">Record Storage</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="ScanController.html">ScanController</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="SensorsAndActuators.html">Sensors and Actuators</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Terminal.html">Terminal</a>
      </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-toggle"></button>
    <span class="nav-text">Modules</span>
    <ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Modules.html">Module Overview</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="AdvertisingModule.html">AdvertisingModule</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="DebugModule.html">DebugModule</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="DfuModule.html">DfuModule</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="EnrollmentModule.html">EnrollmentModule</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="IoModule.html">IoModule</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="MeshAccessModule.html">MeshAccessModule</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="ScanningModule.html">ScanningModule</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="StatusReporterModule.html">StatusReportModule</a>
      </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-toggle"></button>
    <span class="nav-text">Simulator</span>
    <ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="CherrySim.html">CherrySim</a>
      </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-toggle"></button>
    <span class="nav-text">Measurements</span>
    <ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Battery-Consumption.html">Battery Consumption</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Throughput.html">Throughput</a>
      </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-toggle"></button>
    <span class="nav-text">The Fruitymesh Algorithm</span>
    <ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="The-FruityMesh-Algorithm.html">The Fruitymesh Algorithm Basics</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="The-Algorithm-in-Detail.html">The Algorithm in Detail</a>
      </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-toggle"></button>
    <span class="nav-text">Tutorials</span>
    <ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Tutorials.html">Tutorial Overview</a>
      </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="Implementing-a-Custom-Module.html">Implementing a Custom Module</a>
      </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="FAQ.html">FAQ</a>
      </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="FAQ.html">FAQ</a>
      </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="navigation-explore" data-panel="explore">
  <div class="context">
    <span class="version">master</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="index.html">master</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
  <main class="main" role="main">
<article class="doc"><a name="section-top"></a>
<div class="sect1">
<h2 id="_implementing_a_custom_module"><a class="anchor" href="#_implementing_a_custom_module"></a>Implementing a Custom Module</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This tutorial guides you through the process of creating a new
FruityMesh module. You&#8217;ll implement a PingModule that allows you to ping a
node and get its response. You&#8217;d normally implement ping functionality
into the StatusReporter oder DebugModule, which is where it belongs, but
the use-case acts as a good and easy example for building your own
module. You can find the finished files in the folder <code>src/examples</code> or
you can just follow the tutorial.</p>
</div>
<div class="sect2">
<h3 id="_what_is_a_module"><a class="anchor" href="#_what_is_a_module"></a>What Is A Module?</h3>
<div class="paragraph">
<p>Modules are used to structure functionality that doesn&#8217;t directly
interfer with the mesh-logic. Modules extend the <code>Module</code> class. Each
module has the possibility to save a <strong>persistent configuration</strong>. It can
be loaded or unloaded and it is possible to decide which modules are
part of the firmware during compile time. A module can choose to
register a <strong>UART listener</strong> and react on commands, it can also <strong>output
to UART</strong> for logging or communication purposes. It can also <strong>send data
packets</strong> through the mesh and <strong>receive data</strong>.</p>
</div>
<div class="paragraph">
<p>Here is an overview over some of the handlers that it can use:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>ConfigurationLoadedHandler</strong>: Is called when a new Module
configuration is loaded.</p>
</li>
<li>
<p><strong>TimerEventHandler</strong>: Is called at a fixed interval to do periodic
tasks.</p>
</li>
<li>
<p><strong>BleHandlers</strong>: Several handlers that are called when low level ble events
occur.</p>
</li>
<li>
<p><strong>MeshMessageReceivedEventHandler</strong>: Delivers data that has been sent
over the mesh.</p>
</li>
<li>
<p><strong>TerminalCommandHandler</strong>: Gets called when data is received over UART.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_creating_a_ping_module"><a class="anchor" href="#_creating_a_ping_module"></a>Creating A Ping Module</h3>
<div class="paragraph">
<p>The following guide outlines the steps to implement a simple module that
can ping another node over the network and parse the response.</p>
</div>
<div class="sect3">
<h4 id="_step_1"><a class="anchor" href="#_step_1"></a>Step 1</h4>
<div class="paragraph">
<p>First, clone the <code>TemplateModule.cpp</code> and <code>TemplateModule.h</code> file from
the <code>src/examples</code> directory into <code>src/modules/PingModule.cpp</code> and
<code>src/modules/PingModule.h</code>. You need to refactor the method names and
some other variables. Use the search function and look for the string
"template" anywhere in these two files and rename them accordingly.</p>
</div>
</div>
<div class="sect3">
<h4 id="_step_2"><a class="anchor" href="#_step_2"></a>Step 2</h4>
<div class="paragraph">
<p>Activate your module by instantiating it in the featureset
<code>config/featuresets/github_nrf52.cpp</code> where all the other modules are instantiated.
You might need to increase the MAX_MODULE_COUNT in <code>config/Config.h</code>.
Your PingModule Constructor needs a ModuleId for instantiation. All
Module IDs are specified in types.h (enum ModuleId) as well. An
enum entry is already reserved under the section "Other Modules", see
<code>PING_MODULE=201</code>. If you would like to create another module you&#8217;d have
to add the ModuleId to this enum.</p>
</div>
<div class="paragraph">
<p>The initialization inside the featureset may look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C++ hljs" data-lang="C++">size += GS-&gt;InitializeModule&lt;PingModule&gt;(createModule);</code></pre>
</div>
</div>
<div class="paragraph">
<p>, just like the other modules in that file. Note that you have to add
the return value of <code>InitializeModule</code> to the size of all modules and
pass it the boolean <code>createModule</code> so that the firmware is able to
determine how much memory must be allocated for all the modules.</p>
</div>
<div class="paragraph">
<p>You should also include the new <code>"PingModule.h"</code>.</p>
</div>
<div class="paragraph">
<p>Once the module&#8217;s .cpp file is in the modules folder, it will automatically be included in the compilation.</p>
</div>
</div>
<div class="sect3">
<h4 id="_step_3"><a class="anchor" href="#_step_3"></a>Step 3</h4>
<div class="paragraph">
<p>Now go ahead and try to compile the binary and flash it to a device.
Connect via terminal and input <strong>get_modules this</strong>. You should now see a
list of modules and the ID of your new Ping module should be part of it.</p>
</div>
<div class="paragraph">
<p>It doesn&#8217;t do much yet. You will now add more functionality.</p>
</div>
</div>
<div class="sect3">
<h4 id="_step_4"><a class="anchor" href="#_step_4"></a>Step 4</h4>
<div class="paragraph">
<p>Your PingModule does already overwrite a few of the methods in its
base-class. One of these is the TerminalCommandHandler. It is kept
simple for this tutorial and only implements the ping command so
that it can be triggered via a locally connected terminal. (It would
also be possible to trigger a remote node to send a ping and communicate
the result back to another node).</p>
</div>
<div class="paragraph">
<p>In the TerminalCommandHandler, add the following lines to the beginning
of the function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C++ hljs" data-lang="C++">if(TERMARGS(0, "pingmod")){
    //Get the id of the target node
    NodeId targetNodeId = Utility::StringToU16(commandArgs[0]);
    logt("PINGMOD", "Trying to ping node %u", targetNodeId);

    //TODO: Send ping packet to that node

    return TerminalCommandHandler::SUCCESS;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The command name and command arguments should be in lowercase letters to
be consistent with other commands.</p>
</div>
<div class="paragraph">
<p>Next, flash it to your device again and watch if it reacts on your
pingmod command. If it does not, make sure you are using the logtag
"PINGMOD" and you either enable it by writing <strong>debug pingmod</strong> in the
terminal first, or you enable the logtag by default in FruityMesh.cpp.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="_images/tutorial-pingmod.png" alt="pingmod_1"></span></p>
</div>
</div>
<div class="sect3">
<h4 id="_step_5"><a class="anchor" href="#_step_5"></a>Step 5</h4>
<div class="paragraph">
<p>Now that the module is reacting to our command, you are ready to send the ping
packet. Because this is going to be a very simple message, we will use a
predefined message format called <a href="Specification.html#connPacketModule" class="page">connPacketModule</a>. This packet is
intended to be used for triggering actions and for responding to these
triggers. It has a special message header that contains the moduleId and
an actionType. This will ensure that they do not interfere with mesh
messages or messages from other modules.</p>
</div>
<div class="paragraph">
<p>To keep our module messages organized, add an enum that contains
all of our messages in the <code>private:</code> section of our <code>PingModule.h</code>
file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C++ hljs" data-lang="C++">enum PingModuleTriggerActionMessages{
    TRIGGER_PING=0
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, add the code that is responsible for sending this packet to the
other node. The previously written code now looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C++ hljs" data-lang="C++">if(TERMARGS(0, "pingmod")){
    //Get the id of the target node
    NodeId targetNodeId = Utility::StringToU16(commandArgs[0]);
    logt("PINGMOD", "Trying to ping node %u", targetNodeId);

    //Some data
    u8 data[1];
    data[0] = 123;

    //Send ping packet to that node
    SendModuleActionMessage(
            MessageType::MODULE_TRIGGER_ACTION,
            targetNodeId,
            PingModuleTriggerActionMessages::TRIGGER_PING,
            0,
            data,
            1,
            false
    );

    return TerminalCommandHandler::SUCCESS;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This code creates a buffer of 1 byte and fills in some data (123). This
data is not necessary for a ping and is only added for illustration
purposes. The message is sent as a ModuleMessage with the moduleId
automatically added by the <code>SendModuleActionMessage</code> method. The
actionType is TRIGGER_PING. The message type
<code>MessageType::MODULE_TRIGGER_ACTION</code> is used for sending messages that
await a response.</p>
</div>
<div class="paragraph">
<p>The ConnectionManager (cm) will handle the transmission of this packet,
it will copy the packet to its buffer and queue the packet transmission.
It is important to pass the size of payload (1). The last parameter is
used to specify that this packet should be transmitted by using
BLE-unacknowledged packet transmission (WRITE_CMD).</p>
</div>
</div>
<div class="sect3">
<h4 id="_step_6"><a class="anchor" href="#_step_6"></a>Step 6</h4>
<div class="paragraph">
<p>Next, you will check if the packet arrived at its destination.
Implement the MeshMessageReceivedEventHandler in the PingModule.
It looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C++ hljs" data-lang="C++">void PingModule::MeshMessageReceivedHandler(BaseConnection* connection, BaseConnectionSendData* sendData, connPacketHeader* packetHeader)
{
    //Must call superclass for handling
    Module::MeshMessageReceivedHandler(connection, sendData, packetHeader);

    //Filter trigger_action messages
    if(packetHeader-&gt;messageType == MessageType::MODULE_TRIGGER_ACTION){
        connPacketModule* packet = (connPacketModule*)packetHeader;

        //Check if our module is meant and we should trigger an action
        if(packet-&gt;moduleId == moduleId){
            //It's a ping message
            if(packet-&gt;actionType == PingModuleTriggerActionMessages::TRIGGER_PING){

                //Inform the user
                logt("PINGMOD", "Ping request received with data: %d", packet-&gt;data[0]);

                //TODO: Send ping response
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the <code>PingModule.h</code>, you must now also add the definition for this
handler or uncomment it.</p>
</div>
<div class="paragraph">
<p>You can now perform a simple test by flashing this new firmware on your
development board again. There is a simple trick that allows you to test
the functionality with a single node by pinging the node itself:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="_images/tutorial-pingmod2.png" alt="pingmod_2"></span></p>
</div>
<div class="paragraph">
<p>The ConnectionManager will parse the packet and will route it back to
the MeshMessageReceived without broadcasting it because the nodeId is
the same as its own. As you can see, the packet triggered the
appropriate action in the node.</p>
</div>
</div>
<div class="sect3">
<h4 id="_step_7"><a class="anchor" href="#_step_7"></a>Step 7</h4>
<div class="paragraph">
<p>With this working, you should now perform a test with two different
nodes. Flash both of them, connect with two terminals and watch how the
packet is delivered:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="_images/tutorial-pingmod3.png" alt="pingmod_3"></span></p>
</div>
</div>
<div class="sect3">
<h4 id="_step_8"><a class="anchor" href="#_step_8"></a>Step 8</h4>
<div class="paragraph">
<p>Now, a proper ping message should, well, &#8230;&#8203; pong. That&#8217;s why there is a need
for a return packet. Go to <code>PingModule.h</code> and add another enum that contains
action responses:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C++ hljs" data-lang="C++">enum PingModuleActionResponseMessages{
    PING_RESPONSE=0
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, go back to your .cpp file and insert this updated code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C++ hljs" data-lang="C++">void PingModule::MeshMessageReceivedHandler(BaseConnection* connection, BaseConnectionSendData* sendData, connPacketHeader* packetHeader)
{
    //Must call superclass for handling
    Module::MeshMessageReceivedHandler(connection, sendData, packetHeader);

    //Filter trigger_action messages
    if(packetHeader-&gt;messageType == MessageType::MODULE_TRIGGER_ACTION){
        connPacketModule* packet = (connPacketModule*)packetHeader;

        //Check if our module is meant and we should trigger an action
        if(packet-&gt;moduleId == moduleId){
            //It's a ping message
            if(packet-&gt;actionType == PingModuleTriggerActionMessages::TRIGGER_PING){

                //Inform the user
                logt("PINGMOD", "Ping request received with data: %d", packet-&gt;data[0]);

                u8 data[2];
                data[0] = packet-&gt;data[0];
                data[1] = 111;

                //Send ping packet to that node
                SendModuleActionMessage(
                        MessageType::MODULE_ACTION_RESPONSE,
                        packetHeader-&gt;sender,
                        PingModuleActionResponseMessages::PING_RESPONSE,
                        0,
                        data,
                        2,
                        false
                );
            }
        }
    }

    //Parse Module action_response messages
    if(packetHeader-&gt;messageType == MessageType::MODULE_ACTION_RESPONSE){

        connPacketModule* packet = (connPacketModule*)packetHeader;

        //Check if our module is meant and we should trigger an action
        if(packet-&gt;moduleId == moduleId)
        {
            //Somebody reported its connections back
            if(packet-&gt;actionType == PingModuleActionResponseMessages::PING_RESPONSE){
                logt("PINGMOD", "Ping came back from %u with data %d, %d", packet-&gt;header.sender, packet-&gt;data[0], packet-&gt;data[1]);
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This code sends a response to the ping request, includes the data that
came with the initial request and adds some more data. Also, it adds
another condition that checks for the reply to the ping request and
prints it out on the terminal.</p>
</div>
</div>
<div class="sect3">
<h4 id="_step_9"><a class="anchor" href="#_step_9"></a>Step 9</h4>
<div class="paragraph">
<p>That&#8217;s it. You should now be able to ping any node in the mesh network
and see its response. The intermediate nodes will automatically route
all traffic without having to know what kind of message it is.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="_images/tutorial-pingmod4.png" alt="pingmod_4"></span></p>
</div>
<div class="paragraph">
<p>You would probably want to use a counter with the ping message to
generate a handle for a ping. Then, you&#8217;d be able to calculate the time
that it took for the packet to come back through the mesh. And as inidicated
in the beginning, you would not necessarily want to create new module for
pinging other nodes but you&#8217;d have that functionality in a core module.</p>
</div>
<div class="paragraph">
<p>This concludes the tutorial. Have fun implementing new modules for
your FruityMesh!</p>
</div>
</div>
</div>
</div>
</div>
</article>
<aside class="article-aside hidden" role="navigation">
  <h3 class="toc-title"></h3>
  <div id="article-toc"></div>
</aside>
  </main>
</div>
  <footer class="footer fruitymesh-footer-padding">
<p>This project is under active development at the <a href="http://www.mwaysolutions.com/" >M-Way Solutions GmbH,</a> Germany.</p>
<p>We use FruityMesh ourselves in conjunction with our custom MeshGateway to build services such as connected lights, asset tracking and much more for our customers.</p>
</footer>
<script type="text/javascript">
  window.antora = window.antora || {}
  window.antora.basePath = '..'
  window.antora.pagePath = '/fruitymesh/Implementing-a-Custom-Module.html'
</script>
<script src="../_/js/site.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.6/lunr.min.js"></script>
<script src="../_/js/vendor/search.js"></script>
<script async src="../_/../search-index.js"></script>
<script src="../_/js/vendor/highlight.js"></script>
<script src="../_/js/vendor/zoom.js"></script>
<script>hljs.initHighlighting()</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.1.1/tocbot.min.js"></script>
<script>
  tocbot.init({
    tocSelector: '#article-toc',
    contentSelector: 'article',
    headingSelector: 'h2, h3, h4, h5, h6',
    collapseDepth: 6,
    positionFixedSelector: '#article-toc',
    scrollSmooth: true,
  });
  var tocList = document.getElementById('article-toc').getElementsByClassName('toc-list');
  if (tocList && tocList.length > 0 && tocList[0].childNodes.length > 0) {
    document.getElementById('article-toc').parentNode.classList.remove('hidden');
  }
</script>
</body>

</html>
