<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Concepts :: Fruitymesh</title>
  <link rel="canonical" href="http://mwaylabs.github.io/fruitymesh/fruitymesh/Concepts.html">
  <meta name="generator" content="Antora 2.1.1">
  <link rel="stylesheet" href="../_/css/site.css">
  <link rel="stylesheet" href="../_/css/footer.css">
</head>

<body class="article">
  <header class="header" role="banner">
<header class="header" role="banner">
  <div class="navbar-top">
    <a class="navbar-logo" id="fruitymesh-logo-padding" href="https://mwaylabs.github.io/fruitymesh/fruitymesh/index.html">
      <div class="navbar-item">
        <img src="../_/img/fruitymesh_logo.png" alt="Fruitymesh">
      </div>
    </a>
    <div class="navbar-item">
      <div id="search-wrapper" class="border-color-fruitymesh>
        <input id="search-input" type="text" placeholder="Search...">
      </div>
    </div>
  </div>
  <nav class="navbar-bottom fruitymesh-header-color">
    <a href="https://github.com/mwaylabs/fruitymesh">
      <div class="navbar-item">Fruitymesh on Github</div>
    </a>
  </nav>
</header>

</header>
  <div class="main-wrapper">
<div class="navigation-container" data-component="" data-version="master">
  <aside class="navigation" role="navigation">
    <div class="panels">
<div class="navigation-menu is-active" data-panel="menu">
  <button class="navigation-toggle"></button>
  <nav class="nav-menu">
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
    <ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="Quick-Start.html">Quick Start</a>
      </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="BasicUsage.html">Basic Usage</a>
      </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="Concepts.html">Concepts</a>
      </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="Features.html">Features</a>
      </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="Specification.html">Specification</a>
      </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-toggle"></button>
    <span class="nav-text">Developers</span>
    <ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Developers.html">Developer Overview</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Class-Structure.html">Class Structure</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Debugging.html">Debugging</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="ModuleDocumentationTemplate.html">Module Documentation Template</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="BuildingWithCMake.html">Building with CMake</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VsCodeSetup.html">VsCode Setup</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="CppCheck.html">CppCheck Setup</a>
      </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-toggle"></button>
    <span class="nav-text">Mesh</span>
    <ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Node.html">Node</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Connections.html">Connections</a>
      </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-toggle"></button>
    <span class="nav-text">Core Functionality</span>
    <ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="AdvertisingController.html">AdvertisingController</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="BoardConfig.html">Board Configuration</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="FruityHal.html">FruityHal</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Logger.html">Logger</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="RawData.html">RawData Protocol</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="RecordStorage.html">Record Storage</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="ScanController.html">ScanController</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="SensorsAndActuators.html">Sensors and Actuators</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Terminal.html">Terminal</a>
      </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-toggle"></button>
    <span class="nav-text">Modules</span>
    <ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Modules.html">Module Overview</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="AdvertisingModule.html">AdvertisingModule</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="DebugModule.html">DebugModule</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="DfuModule.html">DfuModule</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="EnrollmentModule.html">EnrollmentModule</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="IoModule.html">IoModule</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="MeshAccessModule.html">MeshAccessModule</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="ScanningModule.html">ScanningModule</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="StatusReporterModule.html">StatusReportModule</a>
      </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-toggle"></button>
    <span class="nav-text">Simulator</span>
    <ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="CherrySim.html">CherrySim</a>
      </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-toggle"></button>
    <span class="nav-text">Measurements</span>
    <ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Battery-Consumption.html">Battery Consumption</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Throughput.html">Throughput</a>
      </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-toggle"></button>
    <span class="nav-text">The Fruitymesh Algorithm</span>
    <ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="The-FruityMesh-Algorithm.html">The Fruitymesh Algorithm Basics</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="The-Algorithm-in-Detail.html">The Algorithm in Detail</a>
      </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-toggle"></button>
    <span class="nav-text">Tutorials</span>
    <ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Tutorials.html">Tutorial Overview</a>
      </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Implementing-a-Custom-Module.html">Implementing a Custom Module</a>
      </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="FAQ.html">FAQ</a>
      </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="FAQ.html">FAQ</a>
      </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="navigation-explore" data-panel="explore">
  <div class="context">
    <span class="version">master</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="index.html">master</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
  <main class="main" role="main">
<article class="doc"><a name="section-top"></a>
<h1>Concepts</h1>
<div class="sect1">
<h2 id="_basic_fruitymesh_concepts"><a class="anchor" href="#_basic_fruitymesh_concepts"></a>Basic FruityMesh concepts</h2>
<div class="sectionbody">
<div class="paragraph">
<p>FruityMesh is a profile specification of a connection-based Bluetooth Mesh implementation, developed and published by M-Way Solutions GmbH. Our commercial implementation is called BlueRange.</p>
</div>
<div class="paragraph">
<p>This document explains the basic concepts of FruityMesh and gives an overview of the operation and capabilities. It also explains the life cycle of the mesh network and a mesh device (aka. node). Also, it offers some direct comparisons to the BLE SIG mesh implementation.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_relation_to_bluetooth_low_energy"><a class="anchor" href="#_relation_to_bluetooth_low_energy"></a>Relation to Bluetooth Low Energy</h2>
<div class="sectionbody">
<div class="paragraph">
<p>FruityMesh is based on the Bluetooth low energy part of the Bluetooth 4.1 Specification and is built on top of the host layer. On-air, FruityMesh physical representation is compatible with existing Bluetooth low energy devices as mesh messages are contained inside the payload of Bluetooth low energy connection packets. FruityMesh adds logic on top of the Bluetooth low energy host layer to automatically build connections with other mesh devices within the same mesh network. As it is implemented on top of the host, just as any normal BLE application would be, it is highly portable between chipsets and fully compatible with other Bluetooth Low Energy devices.</p>
</div>
<div class="paragraph">
<p>In contrast to the SIG mesh, there is no use-case specific node configuration necessary. There is no concept of relay nodes, friend nodes or proxy nodes as each Node can do this decision based on the FruityMesh Algorithm at Runtime. There is however a concept of a Gateway (Sink) and Asset Nodes (movable nodes with very little battery capacity). Also, leaf nodes (aka. friend nodes) can be used for very specific use-cases. See <a href="#deviceTypes">Device Types</a> for more explanation.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="_images/fruitymesh.png" alt="FruityMesh"></span></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_application_areas"><a class="anchor" href="#_application_areas"></a>Application areas</h2>
<div class="sectionbody">
<div class="paragraph">
<p>FruityMesh, in opposite to the Bluetooth (SIG) Mesh, uses standard Bluetooth low energy connections. This allows it to be much more power efficient and can also allow all nodes to run with battery power, depending on the use-case. While a SIG mesh node needs to scan at all times to be able to receive messages, FruityMesh nodes have scheduled connections with their connection partners. This has the other advantage that the mesh throughput is multiple times higher for FruityMesh nodes.</p>
</div>
<div class="paragraph">
<p>FruityMesh targets both simple control or monitoring applications as well as sensor data collection or asset tracking. It is a better solution than the SIG mesh once a higher throughput or battery efficiency is required. Is can be used for lighting and automation as there is often the need to collect sensor data in the same network or combine it with asset tracking.</p>
</div>
<div class="paragraph">
<p>Per specification, FruityMesh supports up to 1999 nodes in one network, with a maximum network diameter of 1000 hops.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_network_topology_and_relaying"><a class="anchor" href="#_network_topology_and_relaying"></a>Network topology and relaying</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The FruityMesh algorithm builds a connection-based network graph that is a tree. It guarantees, that each node is connected to this network if the node can reach at least one node that is part of the network. Each node can send messages to any other node within the network because every node can relay messages in the network tree. Because the algorithm guarantees that there are no circles in the connection-based network, messages do not need a time to live.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="_images/connection-based.png" alt="connection-based"></span></p>
</div>
<div class="paragraph">
<p>Using MeshAccess Connections (similar to the GATT Proxy in the SIG mesh), it is possible for non-mesh devices, such as Smartphones to connect to a mesh network. This can also be used to set up connections between a mesh and a node of a different mesh.</p>
</div>
<div class="sect2">
<h3 id="_mesh_transport"><a class="anchor" href="#_mesh_transport"></a>Mesh transport</h3>
<div class="paragraph">
<p>Standard Bluetooth Low Energy connections are utilized by FruityMesh to create its mesh network. Once connected, two FruityMesh nodes will use the BLE GATT protocol to exchange information. A BLE service with RX and TX characteristics is used to transport serial data from node to node. The packet format is specified fully in the <a href="Specification.html" class="page">Specification</a>. The connections are encrypted using the NetworkKey as Long Term Key. This key is exchanged during enrollment (aka. provisioning).</p>
</div>
</div>
<div class="sect2">
<h3 id="_throughput"><a class="anchor" href="#_throughput"></a>Throughput</h3>
<div class="paragraph">
<p>As mentioned, FruityMesh has much higher throughput than the SIG Mesh. The difference is in transport layer - FruityMesh uses more reliable Bluetooth Low Energy connections. It has been measured that FruityMesh has a 16 (!) times higher throughput than Bluetooth Mesh. This exact measurement depends on multiple factors such as node density, interference and the used connection parameters. However, because of the underlying transport, FruityMesh will most likely perform better in any use-case.</p>
</div>
</div>
<div class="sect2">
<h3 id="_relaying"><a class="anchor" href="#_relaying"></a>Relaying</h3>
<div class="paragraph">
<p>Each node in the network relays received messages in all directions except the direction from which a message was received. If the node is the only receiver of the message, the message will not be relayed. There are also special messages that only travel a specific number of hops. In some cases, such as messages being sent to a gateway, it is possible to improve the message relaying using a routing table to optimize throughput. Because there are no circles in the network, there is no need to cache received messages as must be done in the SIG mesh.</p>
</div>
</div>
<div class="sect2">
<h3 id="_power_consumption"><a class="anchor" href="#_power_consumption"></a>Power consumption</h3>
<div class="paragraph">
<p>Because FruityMesh, unlike Bluetooth SIG Mesh does not need to continuously keep the radio in listening mode, it has a significantly lower power consumption and makes it an ideal solution for energy harvesting hardware solutions. In other cases, such as Asset tracking, however, the nodes will need to listen for advertising messages. Depending on the required latency of the asset tracking, this can significantly increase the power consumption.</p>
</div>
<div class="paragraph">
<p>For more information on battery consumption of FruityMesh, read the <a href="Battery-Consumption.html" class="page">Battery Consumption</a> chapter.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_proxy"><a class="anchor" href="#_proxy"></a>Proxy</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Each FruityMesh node will allow standard BLE connections if it has free resources. This means, that any legacy Bluetooth Low Energy device has the possibility to connect to the mesh by either using the MeshAccess connection protocol or by implementing a custom connection type. This is similar to the SIG mesh GATT proxy, but doesn&#8217;t interfere with the mesh in a similar manner as it can be scheduled much better together with mesh activity. The MeshAccessConnections provide security and can be used with a number of different keys. More information about connecting to a mesh network can be found in the documentation of the <a href="MeshAccessModule.html" class="page">MeshAccessModule</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="deviceTypes"><a class="anchor" href="#deviceTypes"></a>Device Types (aka. Node Types)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>FruityMesh supports a number of different device types for different use cases. Most of the time, the default <code>STATIC</code> device type should be used. It is expected that static nodes remain at a fixed position. If these nodes are moved by a significant distance, the algorithm will need to reconfigure the connections, which will result in an instable mesh at the time of moving.</p>
</div>
<div class="paragraph">
<p>Another use-case is that there is a core network of static nodes and some nodes (such as e.g. sensors), that might be moved around. The moving nodes should be configured as <code>LEAF</code> nodes. They will then not relay messages but will be connected to by one of the static nodes. The static nodes serve as the backbone of the network. Care must be taken that the number of leaf nodes is not higher than the number of static nodes in an area as the static nodes have a limit of connections. This could cause a situation in which some leaf nodes are not connected to the network.</p>
</div>
<div class="paragraph">
<p>If there is a high number of moving nodes, these should be configured as <code>ASSET</code> nodes. By default, they will only send data to the mesh using broadcasts, but they are also connectable using <a href="MeshAccessModule.html" class="page">MeshAccess Connections</a>. The asset will broadcast once it has data that it wants to deliver to the mesh. Setting up the MeshAccess Connection needs to be implemented in a MeshGateway as this is something that needs to be centrally scheduled.</p>
</div>
<div class="paragraph">
<p>Last, there is the <code>SINK</code> device type. This is also considered to be a static node and something also referred to as a MeshGateway. A special <a href="Specification.html##NodeIds" class="page">Node Id</a> is assigned to all connected sink nodes and messages to this node id are only received by devices configured as sink nodes.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_addressing"><a class="anchor" href="#_addressing"></a>Addressing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The FruityMesh addressing scheme is similar to the SIG mesh addressing:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Broadcast Address</strong><br>
The special address 0 can be used to send a message to all devices in the mesh at one time.</p>
</li>
<li>
<p><strong>NodeId</strong><br>
A NodeId is assigned to a node once it is added to a mesh network. Unicast addresses can be used by any application to directly send a message to a device. This is a unicast address.</p>
</li>
<li>
<p><strong>GroupId</strong><br>
A group address may represent any number of devices and a device may be part of any number of groups. These groups can be defined at compile time or can be configured and changed at runtime. A single message can therefore be used to contact any number of nodes in the network.</p>
</li>
<li>
<p><strong>Virtual addresses</strong><br>
The virtual addresses are temporary addresses that are assigned to devices that connect to the mesh network using the MeshAccess connections.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are more address types available and documented here: <a href="Specification.html#NodeIds" class="page">Node Ids</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_modules"><a class="anchor" href="#_modules"></a>Modules</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Just like Bluetooth Mesh communication is structured into models and elements, communication within FruityMesh is structured into modules. The idea is very similar to the SIG Mesh: communication is structured, so that new components can easily be created and are interoperable.</p>
</div>
<div class="paragraph">
<p>Each module has a purpose and a known address (moduleId) within the network. We can then send messages to this module and it will process them if they are understood. If not, they will be ignored.</p>
</div>
<div class="paragraph">
<p>Currently there are few generic modules that ease development of FruityMesh based applications. These are part of the standard, e.g. the StatusReporterModule or the EnrollmentModule and have a well defined set of messages. You can find the full list of FruityMesh modules <a href="Modules.html" class="page">here</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_enrollment_provisioning"><a class="anchor" href="#_enrollment_provisioning"></a>Enrollment / Provisioning</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This documentation is often referring to the term <em>enrolling</em> which is essentially the same as <em>provisioning</em>. Those terms are referring to the same actions of adding node to a network.</p>
</div>
<div class="paragraph">
<p>Before a device can participate in a mesh network, it must be provisioned. During provisioning, a device is added to the network by assigning a NodeId, the NetworkKey and a number of other optional keys. The provisioning is done by a Provisioner, which is a trusted device with access to the full list of devices in the network. FruityMesh enables provisioning through mobile apps or Gateways, such as the SIG mesh. In addition to that, provisioning over the mesh is also possible. This allows us to provision whole buildings with a single provisioner that does not need to move around. A more detailed description can be found in the <a href="EnrollmentModule.html" class="page">EnrollmentModule</a> documentation.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_security"><a class="anchor" href="#_security"></a>Security</h2>
<div class="sectionbody">
<div class="paragraph">
<p>FruityMesh employs several security measures to prevent third-party interference and monitoring. Each device is flashed with a unique and cryptographically secure 128bit NodeKey (Device Key). This key is used to set up a secure connection with the provisioner and is transmitted out of band, e.g. by using a QR code. A less secure option of initially enrolling nearby devices without the device key is also supported and can be enabled. After provisioning, the node possesses a NetworkKey that is used to encrypt all communication in the mesh.</p>
</div>
<div class="paragraph">
<p>Optionally, a UserBaseKey and an OrganizationKey can be given during enrollment. These keys can be used to authenticate multiple users and to decrypt information from assets that move within an organization. The different key types are documented <a href="Specification.html#EncryptionKeys" class="page">here</a>.</p>
</div>
<div class="paragraph">
<p>Both mesh connections and MeshAccessConnections use AES encryption and are protected using a MIC and a nonce from replay, man in the middle, known plaintext or other known attacks.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_summary"><a class="anchor" href="#_summary"></a>Summary</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_fruitymesh_is_easy_to_setup"><a class="anchor" href="#_fruitymesh_is_easy_to_setup"></a>FruityMesh is easy to setup</h3>
<div class="paragraph">
<p>There is no need for configuring anything options such as proxy node, relay node, advertising channels, etc,&#8230;&#8203; manually such as in SIG mesh. As FruityMesh allows provisioning over the mesh and with a Gateway it can be done from remote, which is not possible for Bluetooth Mesh.</p>
</div>
</div>
<div class="sect2">
<h3 id="_fruitymesh_is_low_power"><a class="anchor" href="#_fruitymesh_is_low_power"></a>FruityMesh is low power</h3>
<div class="paragraph">
<p>As FruityMesh uses standard BLE connections it is much better optimized for power consumption. Hence there is no need to distinguish between battery powered nodes or nodes powered by electricity. It also means that there is no need for additional manual configuration of low power nodes as all FruityMesh nodes are low power.</p>
</div>
</div>
<div class="sect2">
<h3 id="_fruitymesh_is_fast"><a class="anchor" href="#_fruitymesh_is_fast"></a>FruityMesh is fast</h3>
<div class="paragraph">
<p>The achievable throughput of FruityMesh has been measured to be up to 16 times as high as the SIG mesh throughput.</p>
</div>
</div>
<div class="sect2">
<h3 id="_fruitymesh_is_interoperable"><a class="anchor" href="#_fruitymesh_is_interoperable"></a>FruityMesh is interoperable</h3>
<div class="paragraph">
<p>FruityMesh can work with other Bluetooth 4.1 or higher devices. It supports both central and peripheral connections so it can connect to smartphones but also to BLE enabled sensors to collect data.</p>
</div>
</div>
<div class="sect2">
<h3 id="_relation_to_bluetooth_sig_mesh"><a class="anchor" href="#_relation_to_bluetooth_sig_mesh"></a>Relation to Bluetooth SIG Mesh</h3>
<div class="paragraph">
<p>FruityMesh is a technology very similar to Bluetooth Mesh. They both utilize BLE technology to transfer some data to nearby devices, they both require some provisioning to get started, they both use a similar addressing model and both provide many-to-many communication.</p>
</div>
<div class="paragraph">
<p>However, the main difference is the transport layer where FruityMesh uses standard BLE connections while Bluetooth Mesh uses advertising / scanning for communication. FruityMesh approach has many advantages without having any major drawbacks.</p>
</div>
</div>
</div>
</div>
</article>
<aside class="article-aside hidden" role="navigation">
  <h3 class="toc-title">Concepts</h3>
  <div id="article-toc"></div>
</aside>
  </main>
</div>
  <footer class="footer fruitymesh-footer-padding">
<p>This project is under active development at the <a href="http://www.mwaysolutions.com/" >M-Way Solutions GmbH,</a> Germany.</p>
<p>We use FruityMesh ourselves in conjunction with our custom MeshGateway to build services such as connected lights, asset tracking and much more for our customers.</p>
</footer>
<script type="text/javascript">
  window.antora = window.antora || {}
  window.antora.basePath = '..'
  window.antora.pagePath = '/fruitymesh/Concepts.html'
</script>
<script src="../_/js/site.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.6/lunr.min.js"></script>
<script src="../_/js/vendor/search.js"></script>
<script async src="../_/../search-index.js"></script>
<script src="../_/js/vendor/highlight.js"></script>
<script src="../_/js/vendor/zoom.js"></script>
<script>hljs.initHighlighting()</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.1.1/tocbot.min.js"></script>
<script>
  tocbot.init({
    tocSelector: '#article-toc',
    contentSelector: 'article',
    headingSelector: 'h2, h3, h4, h5, h6',
    collapseDepth: 6,
    positionFixedSelector: '#article-toc',
    scrollSmooth: true,
  });
  var tocList = document.getElementById('article-toc').getElementsByClassName('toc-list');
  if (tocList && tocList.length > 0 && tocList[0].childNodes.length > 0) {
    document.getElementById('article-toc').parentNode.classList.remove('hidden');
  }
</script>
</body>

</html>
